import cv2
import os
from django.conf import settings
import uuid

class SteganographyException(Exception):
    pass

class LSBSteg():
    def __init__(self, im):
        self.image = im
        self.height, self.width, self.nbchannels = im.shape
        self.size = self.width * self.height
        
        self.maskONEValues = [1,2,4,8,16,32,64,128]
        # Mask used to put one ex:1->00000001, 2->00000010 .. associated with OR bitwise
        self.maskONE = self.maskONEValues.pop(0) # Will be used to do bitwise operations
        
        self.maskZEROValues = [254,253,251,247,239,223,191,127]
        # Mask used to put zero ex:254->11111110, 253->11111101 .. associated with AND bitwise
        self.maskZERO = self.maskZEROValues.pop(0)
        
        self.curwidth = 0  # Current width position
        self.curheight = 0 # Current height position
        self.curchan = 0   # Current channel position

    def put_binary_value(self, bits): # Put the bits in the image
        for c in bits:
            val = list(self.image[self.curheight,self.curwidth]) # Get the pixel value as a list
            if int(c) == 1:
                val[self.curchan] = int(val[self.curchan]) | self.maskONE # OR with maskONE
            else:
                val[self.curchan] = int(val[self.curchan]) & self.maskZERO # AND with maskZERO
                
            self.image[self.curheight,self.curwidth] = tuple(val)
            self.next_slot() # Move "cursor" to the next space
        
    def next_slot(self): # Move to the next slot where information can be taken or put
        if self.curchan == self.nbchannels-1: # Next Space is the following channel
            self.curchan = 0
            if self.curwidth == self.width-1: # Or the first channel of the next pixel of the same line
                self.curwidth = 0
                if self.curheight == self.height-1: # Or the first channel of the first pixel of the next line
                    self.curheight = 0
                    if self.maskONE == 128: # Mask 1000000, so the last mask
                        raise SteganographyException("No available slot remaining (image filled)")
                    else: # Or instead of using the first bit start using the second and so on..
                        self.maskONE = self.maskONEValues.pop(0)
                        self.maskZERO = self.maskZEROValues.pop(0)
                else:
                    self.curheight +=1
            else:
                self.curwidth +=1
        else:
            self.curchan +=1

    def read_bit(self): # Read a single bit in the image
        val = self.image[self.curheight,self.curwidth][self.curchan]
        val = int(val) & self.maskONE
        self.next_slot()
        if val > 0:
            return "1"
        else:
            return "0"
    
    def read_byte(self):
        return self.read_bits(8)
    
    def read_bits(self, nb): # Read the given number of bits
        bits = ""
        for i in range(nb):
            bits += self.read_bit()
        return bits

    def byteValue(self, val):
        return self.binary_value(val, 8)
        
    def binary_value(self, val, bitsize): # Return the binary value of an int as a byte
        binval = bin(val)[2:]
        if len(binval) > bitsize:
            raise SteganographyException("binary value larger than the expected size")
        while len(binval) < bitsize:
            binval = "0"+binval
        return binval

    def encode_text(self, txt):
        l = len(txt)
        binl = self.binary_value(l, 16) # Length coded on 2 bytes so the text size can be up to 65536 bytes long
        self.put_binary_value(binl) # Put text length coded on 4 bytes
        for char in txt: # And put all the chars
            c = ord(char)
            self.put_binary_value(self.byteValue(c))
        return self.image
       
    def decode_text(self):
        ls = self.read_bits(16) # Read the text size in bytes
        l = int(ls,2)
        i = 0
        unhideTxt = ""
        while i < l: # Read all bytes of the text
            tmp = self.read_byte() # So one byte
            i += 1
            unhideTxt += chr(int(tmp,2)) # Every chars concatenated to str
        return unhideTxt

def encode_message(image_path, message, output_path=None):
    """
    Encode a message into an image using LSB steganography
    """
    try:
        # Read the input image
        img = cv2.imread(image_path)
        if img is None:
            raise SteganographyException("Could not read the image file.")
        
        # Initialize the steganography object
        steg = LSBSteg(img)
        
        # Encode the message
        result = steg.encode_text(message)
        
        # Generate output path if not provided
        if output_path is None:
            # Create unique filename
            filename = f"encoded_{uuid.uuid4().hex}.png"
            output_path = os.path.join(settings.MEDIA_ROOT, 'encoded', filename)
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        # Write the output image
        cv2.imwrite(output_path, result)
        
        return os.path.basename(output_path)
    
    except SteganographyException as e:
        raise e
    except Exception as e:
        raise SteganographyException(f"Encoding failed: {str(e)}")

def decode_message(image_path):
    """
    Decode a message from an image using LSB steganography
    """
    try:
        # Read the input image
        img = cv2.imread(image_path)
        if img is None:
            raise SteganographyException("Could not read the image file.")
        
        # Initialize the steganography object
        steg = LSBSteg(img)
        
        # Decode the message
        message = steg.decode_text()
        
        return message
    
    except SteganographyException as e:
        raise e
    except Exception as e:
        raise SteganographyException(f"Decoding failed: {str(e)}")